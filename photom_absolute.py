import os
import pyfits
import pdb
import shutil
from pyraf import iraf
import numpy as np
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.ticker
iraf.digiphot()
iraf.apphot()
homestr = os.path.expanduser('~')


# TO-DO = The goodbad_flags should not be used here to skip frames... I think that absolute photometry should
# probably be done for both the good and bad frames; only later when analysing the resulting photometry should
# bad frames be discarded from the analysis (eg. the relphot step).

# Set the iraf.phot routine scripting mode:
iraf.phot.interactive = 'no'
iraf.phot.verify = 'no'

def Main( obj, make_plots=True ):
    """
    Does absolute photometry for one or more stars given a list of images.
    Output is generated in the form of two types of file:
       1. starX_absphot.dat for X=0,1,2,... files contain columns with the
          more detailed output for each of the stars, with each line
          corresponding to a different image.
       2. absolute.phot file containing the important numerical columns for
          each of the stars; it's supposed to be the most convenient output
          for use with numpy and for generating relative photometry.

    Summary plots are also generated by default:

      Figure 1:
        ** Top left = traces of xy drift for each of the stars
        ** Bottom left = airmass versus time
        ** Top right = absolute flux versus time for each star
        ** Bottom right = sky annulus value as a function of time for each star

      Figure 2:
        ?? Plots image number versus measured scatter divided by the calculated Poisson noise ??
    """

    # Get the list of reduced images in the data directory:
    red_images = np.loadtxt( obj.red_image_list, dtype='str' )
    if obj.datapars[ 'obstime' ]!='':
        obstimes = np.zeros( len(red_images) )
        # Read the headers and put the observation times into an array:
        for i in range( len(red_images) ):
            h = pyfits.getheader( red_images[i] )
            obstimes[i] = h[ obj.datapars['obstime'] ]
        ixs = np.argsort( obstimes )
        red_images = red_images[ ixs ]
    if obj.nimages_total==None:
        obj.nimages_total = len( red_images )
    if obj.goodbad_flags==None:
        obj.goodbad_flags =  np.ones( obj.nimages_total )
    obj.nimages_good = int( np.sum( obj.goodbad_flags ) )
    # Set the parameters for the various IRAF routines:
    set_iraf_params( obj )
    # Work out how many stars we're doing photometry for:
    if np.rank( obj.coords_input_files )>0:
        obj.nstars = len( obj.coords_input_files )
    else:
        obj.coords_input_files = [ obj.coords_input_files ]
        obj.nstars = 1
    obj.ncomparisons = obj.nstars-1
    # Determine whether we're using the coordinates from the first frame only then updating
    # as we go along, or if we have a list of coordinates for each of the frames already:
    obj.dat_files = []
    if obj.coords_input_type=='init':
        coords_temps = []
    elif obj.coords_input_type=='list':
        coords_lists = []
    # Open the various dat files that will receive the output from iraf.phot and give them
    # a header line recording the aperture parameters used for the photometry:
    open_dat_files = []
    ap_string = '# APERTURE RADIUS = %.2f pixels \n# ANNULUS RADIUS = %.2f pixels \n# DELTA ANNULUS = %.2f pixels\n\n' % \
                ( float( iraf.photpars.apertures ), float( iraf.fitskypars.annulus ), float( iraf.fitskypars.dannulus ) )
    # Refer to the IRAF Phot handbook for further information on the following:
    #   flux = sky-subtracted ADU counts due to star (i.e. sum-sky)
    #   sum = total ADU counts within aperture (i.e. star+sky)
    #   area = number of pixels within aperture
    #   msky = mean sky value ADU counts per pixel (i.e. sky=area*msky)
    #   stdev = standard deviation of the sky values per pixel in ADU counts
    # We will extract the following fields for the output:
    txdump_fields = [ 'otime', 'xairmass', 'xcenter', 'ycenter', 'flux', 'itime', 'area', 'msky', 'stdev', \
                      'cerror', 'serror', 'perror', 'image' ]
    # Set up a dictionary to hold the field name and its corresponding
    # column index in the txdump output file:
    txdump_field_ixs = {}
    for field in txdump_fields:
        txdump_field_ixs[ field ] = i
    # Make a header string containing the column names for the txdump output:
    txdump_fields_str = '# '
    for i in range( len( field_items ) ):
        for j in range( len( field_items ) ):
            if field_items[ j ][ 1 ]==i:
                txdump_fields_str += field_items[ j ][ 0 ]
        if i<len( field_items )-1:
            txdump_fields_str += ', '
        else:
            continue
    # Write the column headings to the files that will hold the photometry output:
    for j in range( obj.nstars ):
        dat_file = ( obj.analysis_dir+'/star%i_absphot.dat' % j).replace( '//' , '/' )
        obj.dat_files = obj.dat_files + [ dat_file ]
        if os.path.isfile( dat_file ): os.remove( dat_file )
        open_dat_files = open_dat_files + [ open( dat_file,'w' ) ]
        open_dat_files[ j ].write( ap_string )
        # Replace some of the txdump keywords for the column header that gets written to file:
        columns_header = str( txdump_fields_str ).replace( 'xairmass', 'airmass' )
        columns_header = str( columns_header ).replace( 'area' , 'ap_area' )
        columns_header = str( columns_header ).replace( 'msky' , 'skyval' )
        columns_header = str( columns_header ).replace( 'stdev' , 'skystdv' )
        columns_header = columns_header + '\n'
        open_dat_files[j].write( columns_header )
        if obj.coords_input_type=='init':
            # Copy the star coordinate files to temporary files that will be overwritten below at
            # the start of each new image to account for shifts in the pointing:
            coords_temps = coords_temps + [ ( obj.analysis_dir+'/star%i_coords.temp' % j ).replace( '//' , '/' ) ]
            shutil.copyfile( obj.coords_input_files[ j ], coords_temps[ j ] )
        elif obj.coords_input_type=='list':
            # Otherwise, we must already have a list of coordinates for each of the images, and we
            # can read these in as a list of xy-arrays, one for each star:
            coords_list = np.loadtxt( obj.coords_input_files[ j ] )
            coords_lists = coords_lists + [ coords_list ]
    # Now go through each of the images, and do aperture photometry for each of the stars:
    for i in range( len( red_images ) ):
        print 'Doing photometry for image %i of %i' % ( i+1, len( red_images ) )
        if obj.goodbad_flags!=None:
            if obj.goodbad_flags[ i ]==0:
                print '( ... current image flagged as bad )'
        for j in range( obj.nstars ):
            coords_temp_filename = ( obj.analysis_dir + '/star%i_coords.temp' % j ).replace( '//', '/' )
            if obj.coords_input_type=='list':
                # If we're using a list of coordinates that has been determined ahead of time,
                # extract the coordinates for the current star on the current image and put them
                # into the temporary coordinates file that IRAF will use:
                coords_string = '%.2f %.2f \n' % ( coords_lists[ j ][ i, 0 ], coords_lists[ j ][ i, 1 ] )
                coords_temp_file = open( coords_temp_filename, 'w' )
                coords_temp_file.write( coords_string )
                coords_temp_file.close()
            # The output of the iraf.phot task will be saved in the temporary mag file:
            mag_temp_filename = ( obj.analysis_dir + '/star%i_mag.temp' % j ).replace( '//', '/' )
            if os.path.isfile( mag_temp_filename ):
                os.remove( mag_temp_filename )
            # Do the photometry for the current star on the current image:
            iraf.phot( image=red_images[ i ], coords=coords_temp_filename, output=mag_temp_filename )
            # Since the mag output file generated by iraf.phot is not very easy to read, we use the
            # iraf.txdump routine to extract the fields we're interested in and append these to the
            # relevant dat file in nice columns:
            iraf.txdump( mag_temp_filename, fields=txdump_fields_str, expr='yes', Stdout=open_dat_files[ j ] )
            # The iraf.phot routine will have refined our estimate for the source coordinates, so we can
            # use these as our initial guess for the next image, assuming the pointing change between images
            # is not too severe:
            os.remove( coords_temp_filename )
            coords_temp_file = open( coords_temp_filename, 'w' )
            iraf.txdump( mag_temp_filename, fields='xcenter,ycenter', expr='yes', Stdout=coords_temp_file )
            coords_temp_file.close()
    # Save the dat files and remove the temporary mag and coords files:
    for j in range( obj.nstars ):
        open_dat_files[ j ].close()
        mag_temp_filename = obj.analysis_dir + '/star%i_mag.temp' % j
        os.remove( mag_temp_filename )
        coords_temp_filename = obj.analysis_dir + '/star%i_coords.temp' % j
        os.remove( coords_temp_filename )
    # If we did not have a list of coordinates for all the images to start with, we can one now using the
    # output from above:
    if obj.coords_input_type=='init':
        coords_init2list( obj, txdump_field_ixs )
    # We can also use the information stored in the dat file to generate a reformatted file that is nicer
    # to use with numpy, having only float entries:
    dats2absphot( obj, txdump_field_ixs )
    # Plot some of the output:
    if make_plots==True:
        plot( obj )
        
    return None

def default_photpars( obj ):
    """
    Installs default values for photpars.
    """
    
    obj.photpars = {}
    obj.photpars[ 'apertures' ] = 7

    return None

def custom_photpars( obj, photpars_apertures='default' ):
    """
    Allows a custom dictionary to be passed in for photpars.
    """
    
    default_photpars( obj )
    if photpars_apertures!='default':
        obj.photpars[ 'apertures' ] = photpars_apertures

    return None

def default_fitskypars( obj ):
    """
    Installs default values for fitskypars.
    """
    
    obj.fitskypars = {}
    obj.fitskypars[ 'annulus' ] = 10
    obj.fitskypars[ 'dannulus' ] = 5
    obj.fitskypars[ 'salgorithm' ] = 'mode'

    return None

def custom_fitskypars( obj, fitskypars_annulus='default', fitskypars_dannulus='default', \
                       fitskypars_salgorithm='default' ):
    """
    Allows a custom dictionary to be passed in for fitskypars.
    """

    default_fitskypars( obj )
    if fitskypars_annulus!='default':
        obj.fitskypars[ 'annulus' ] = fitskypars_annulus
    if fitskypars_dannulus!='default':
        obj.fitskypars[ 'dannulus' ] = fitskypars_dannulus
    if fitskypars_salgorithm!='default':
        obj.fitskypars[ 'salgorithm' ] = fitskypars_salgorithm

    return None

def default_centerpars( obj ):
    """
    Installs default values for centerpars.
    """

    obj.centerpars = {}
    obj.centerpars[ 'maxshift' ] = 5
    obj.centerpars[ 'cbox' ] = 10    
    obj.centerpars[ 'minsnratio' ] = 5    

    return None

def custom_centerpars( obj, centerpars_maxshift='default', centerpars_cbox='default', \
                       centerpars_minsnratio='default' ):
    """
    Allows a custom dictionary to be passed in for centerpars.
    """

    default_centerpars( obj )
    if centerpars_maxshift!='default':
        obj.centerpars[ 'maxshift' ] = centerpars_maxshift
    if centerpars_cbox!='default':
        obj.centerpars[ 'cbox' ] = centerpars_cbox
    if centerpars_minsnratio!='default':
        obj.centerpars[ 'minsnratio' ] = centerpars_minsnratio

    return None

def default_datapars( obj ):
    """
    Installs default values for datapars.
    """

    obj.datapars = {}
    obj.datapars[ 'gain' ] = '' #'EGAIN'
    obj.datapars[ 'readnoise' ] = '' #'READNOISE'    
    obj.datapars[ 'exposure' ] = '' #'EXPTIME'
    obj.datapars[ 'obstime' ] = '' #'HJD_ST'
    obj.datapars[ 'airmass' ] = '' #'AIRMASS'

    return None

def custom_datapars( obj, datapars_gain='default', datapars_readnoise='default', datapars_exposure='default', \
                     datapars_obstime='default', datapars_airmass='default' ):
    """
    Allows a custom dictionary to be passed in for datapars.
    """

    default_datapars( obj )
    if datapars_gain!='default':
        obj.datapars[ 'gain' ] = datapars_gain
    if datapars_readnoise!='default':
        obj.datapars[ 'readnoise' ] = datapars_readnoise        
    if datapars_exposure!='default':
        obj.datapars[ 'exposure' ] = datapars_exposure
    if datapars_obstime!='default':
        obj.datapars[ 'obstime' ] = datapars_obstime
    if datapars_airmass!='default':
        obj.datapars[ 'airmass' ] = datapars_airmass

    return None

def set_iraf_params(obj):
    """
    Sets various IRAF routine parameters.
    """

    iraf.photpars.apertures    = obj.photpars[ 'apertures' ]
    iraf.fitskypars.annulus    = obj.fitskypars[ 'annulus' ]
    iraf.fitskypars.dannulus   = obj.fitskypars[ 'dannulus' ] 
    iraf.fitskypars.salgorithm = obj.fitskypars[ 'salgorithm' ]
    iraf.centerpars.maxshift   = obj.centerpars[ 'maxshift' ]
    iraf.centerpars.cbox       = obj.centerpars[ 'cbox' ]
    iraf.centerpars.minsnratio = obj.centerpars[ 'minsnratio' ]
    iraf.datapars.gain         = obj.datapars[ 'gain' ]
    iraf.datapars.exposure     = obj.datapars[ 'exposure' ]
    iraf.datapars.obstime      = obj.datapars[ 'obstime' ]
    iraf.datapars.airmass      = obj.datapars[ 'airmass' ]

    return None

def coords_init2list( obj, colixs ):
    """
    Uses the output stored in the dat files to produce revised coordinates lists for each of the stars.
    This is useful if you only started with init_coords for the first frame in the series.
    """

    obj.coords_updated_lists = []
    for j in range( obj.nstars ):
        list_filename = str( obj.analysis_dir + '/star%i_coords_updated.list' % j ).replace( '//', '/' )
        obj.coords_updated_lists = obj.coords_updated_lists + [ list_filename ]
        str_block = np.loadtxt( obj.dat_files[ j ], dtype=str, comments='#' )
        xycoords = np.zeros( [ np.shape( str_block )[ 0 ], 2 ] )
        xycoords[ :, 0 ] = np.array( str_block[ :, colixs[ 'xcenter' ] ], dtype=float )
        xycoords[ :, 1 ] = np.array( str_block[ :, colixs[ 'ycenter' ] ], dtype=float )
        np.savetxt( list_filename, xycoords )

    return None

def dats2absphot( obj, colixs ):
    """
    Takes the output stored in the dat files for each of the stars and generates a single file named
    absolute.phot, which is formatted in a more numpy-friendly way. This is because some of the columns
    in the dat files can contain strings instead of floats (eg. the error columns), and also because
    it's nice to have the multiple flux time series in a single file.

    Relevant variables are also generated and stored within the photom object itself.
    """

    # Prepare the arrays that will get written to the output file:
    absphot_file_auxcolumns = [ 'otime', 'itime', 'skyval', 'skystdv', 'airmass' ]
    naux = len( absphot_file_auxcolumns )
    auxixs = {}
    for i in range( naux ):
        auxixs[ absphot_file_auxcolumns[ i ] ] = i
    aux_items = auxixs.items()
    header_string = ''
    format_string = ''
    for i in range( naux ):
        for j in range( naux ):
            if aux_items[ j ][ 1 ]==i:
                header_string += aux_items[ j ][ 0 ]
                format_string += '%s'
        if i<naux-1:
            header_string += ', '
            format_string += ' '
    absphot_val_block = np.empty( [ obj.nimages_total, naux+obj.nstars ], dtype='|S18' )
    # Also set up variables to be contained within the object:
    obj.skyvals = np.zeros( [ obj.nimages_total, obj.nstars ] )
    obj.skystdvs = np.zeros( [ obj.nimages_total, obj.nstars ] )
    obj.xycoords = np.zeros( [ obj.nimages_total, obj.nstars, 2 ] )
    # And keep track of the aperture area that was used for use later on when calculating
    # the formal errors in the photometry:
    aperture_areas = np.zeros( [ obj.nimages_total, obj.nstars ] )
    # First of all, organise the absolute photometry into arrays and write to the absphot
    # output file:
    for j in range( obj.nstars ):
        # Read in the dat output:
        str_block = np.loadtxt( obj.dat_files[ j ], dtype=str, comments='#' )
        # Aperture areas in units of pixels:
        aperture_areas[ :, j ] = np.array( str_block[ :, colixs[ 'area' ] ], dtype=float )
        # Sky mean values in ADU counts per pixel:
        obj.skyvals[ :, j ] = np.array( str_block[ :, colixs[ 'msky' ] ], dtype=float )
        # Sky standard deviations in ADU counts per pixel:
        obj.skystdvs[ :, j ] = np.array( str_block[ :, colixs[ 'stdev' ] ], dtype=float )
        # Chip coordinates:
        xycoords = np.zeros( [ obj.nimages_total, 2 ] )
        obj.xycoords[ :, j, 0 ] = np.array( str_block[ :, colixs[ 'xcenter' ] ], dtype=float )
        obj.xycoords[ :, j, 1 ] = np.array( str_block[ :, colixs[ 'ycenter' ] ], dtype=float )
        # Generate formatted output for the output file:
        if j==0:
            # Observation time:
            try:
                absphot_val_block[ :, auxixs[ 'otime' ] ] = '%.5f' % str_block[ :, colixs[ 'otime' ] ]
                obj.obstimes = np.array( str_block[ :, colixs[ 'otime' ] ], dtype=float )
            except:
                absphot_val_block[ :, auxixs[ 'otime' ] ] = str_block[ :, colixs[ 'otime' ] ]
            # Integration time:
            try:
                absphot_val_block[ :, auxixs[ 'itime' ] ] = '%.1f' % str_block[ :, colixs[ 'itime' ] ]
            except:
                absphot_val_block[ :, auxixs[ 'itime' ] ] = str_block[ :, colixs[ 'itime' ] ]
            # Airmass:
            try:
                absphot_val_block[ :, auxixs[ 'airmass' ] ] = '%.2f' % str_block[ :, colixs[ 'xairmass' ] ]
            except:
                absphot_val_block[ :, auxixs[ 'airmass' ] ] = str_block[ :, colixs[ 'xairmass' ] ]
        # The absolute photometry time series for the current star in ADU counts:
        absphot_val_block[ :, j+naux ] = str_block[ :, colixs[ 'flux' ] ]
        format_string += '  %s'
        header_string += ', star%i' % j
    # Take the median of the sky values and the median of the sky standard deviations:
    absphot_val_block[ :, auxixs[ 'skyval' ] ] = np.median( obj.skyvals, axis=1 )
    absphot_val_block[ :, auxixs[ 'skystdv' ] ] = np.median( obj.skystdvs, axis=1 )
    # Now write the numerical entries to the absphot output file:
    obj.absphot_file = obj.analysis_dir + '/absolute.phot'
    if os.path.isfile( obj.absphot_file ): os.remove( obj.absphot_file )
    np.savetxt( obj.absphot_file, absphot_val_block, fmt=format_string )
    # Append the header to the top of the absphot output file (I do it this way at the
    # moment because the version of numpy that I'm working with doesn't have a header option):
    shutil.copyfile( obj.absphot_file, 'temp.file' )
    outfile = open( obj.absphot_file, 'w' )
    outfile.write( '# '+header_string+'\n' )
    tempfile = open( 'temp.file', 'r' )
    for line in tempfile:
        outfile.write( line )
    outfile.close()
    tempfile.close()
    os.remove( 'temp.file' )
    # Record the other bits of information within the object itself; to check that the indices
    # below are correct for absphot_val_block, check how the array was filled in photom_absolute.py:
    obj.obstimes = np.array( absphot_val_block[ :, auxixs[ 'otime' ] ], dtype=float )
    obj.exptimes = np.array( absphot_val_block[ :, auxixs[ 'itime' ] ], dtype=float )
    obj.airmasses = np.array( absphot_val_block[ :, auxixs[ 'airmass' ] ], dtype=float )
    # Below we convert photometry from ADU to electrons and calculate associated uncertainties:
    obj.absphot_vals_all = np.zeros( [ obj.nimages_total, obj.nstars ] )
    obj.absphot_errs_all = np.zeros( [ obj.nimages_total, obj.nstars ] )
    readnoise_kw = obj.datapars[ 'readnoise' ]
    gain_kw = obj.datapars[ 'gain' ]
    #ixs = ( obj.goodbad_flags==1 )
    images = np.loadtxt( obj.red_image_list, dtype=str )#[ ixs ]
    for i in range( obj.nimages_total ):
        header = pyfits.getheader( images[i] )
        try:
            readnoise = header[ readnoise_kw ]
        except:
            print '\nAssuming readnoise=0 ...\n'
            readnoise = 0
        try:
            gain = header[ gain_kw ]
        except:
            print '\nAssuming gain=1 ...\n'
            gain = 1
        # Make sure we record the absphot values in units of electrons:
        obj.absphot_vals_all[ i, : ] = gain * np.array( absphot_val_block[ i, naux: ], dtype=float )
        # Calculate the formal Poisson errors for each of the stars, again, in units of electrons:
        for j in range( obj.nstars ):
            targ_noise_e2 = obj.absphot_vals_all[ i, j ]
            sky_noise_e2 = aperture_areas[ i, j ] * obj.skyvals[ i, j ] * gain
            read_noise_e2 = aperture_areas[ i, j ] * ( readnoise**2. )
            obj.absphot_errs_all[ i, j ] = np.sqrt( targ_noise_e2 + sky_noise_e2 + read_noise_e2 )

    return None

def plot( obj ):
    """
    Generates and saves figures showing some diagnostic information about the photometry
    contained in obj.

    Figure 1:
      ** Top left = traces of xy drift for each of the stars
      ** Bottom left = airmass versus time
      ** Top right = absolute flux versus time for each star
      ** Bottom right = sky annulus value as a function of time for each star

    Figure 2:
      ?? Plots image number versus measured scatter divided by the calculated Poisson noise ??
    """
    orig_backend = plt.get_backend()
    plt.switch_backend( 'agg' )

    fig1 = plt.figure( figsize=[ 20, 12 ] )
    edge_buffer = 0.08
    markersize = 5
    linewidth = 2
    ax_width = ( 1 - 3*edge_buffer ) / 2.
    ax_height = ax_width
    time_from_start = obj.obstimes - obj.obstimes.min()
    ix = np.argsort( time_from_start )
    xl = time_from_start.min() - 0.05*( time_from_start.max() - time_from_start.min() )
    xu = time_from_start.max() + 0.05*( time_from_start.max()-time_from_start.min() )
    colormap = matplotlib.cm.spectral
    colormap = plt.cm.ScalarMappable( cmap=colormap )
    colormap.set_clim( vmin=0, vmax=1 )
    color_points = np.r_[ 0.1 : 0.9 : 1j*obj.nstars ]
    # Top left panel = xy drift on chip:
    ax_tl = fig1.add_axes( [ edge_buffer, 2*edge_buffer + ax_height, 0.75*ax_width, ax_height ] )
    for i in range( obj.nstars ):
        xcoords = obj.xycoords[ :, i, 0]
        ycoords = obj.xycoords[ :, i, 1]
        color = colormap.to_rgba( color_points[ i ] )
        ax_tl.plot( xcoords[ ix ], ycoords[ ix ], '-o', lw=linewidth, mfc=color, mec=color, c=color, ms=markersize, label='star%i' % i )
        ax_tl.text( xcoords[ ix ][ 0 ], ycoords[ ix ][ 0 ], 'star%i' % i )
    ax_tl.set_title( 'Pointing Drift' )
    ax_tl.set_xlabel( 'X Coordinate (pixels)' )
    ax_tl.set_ylabel( 'Y Coordinate (pixels)' )
    # Get the chip dimensions to set the xlim and ylim values to size:
    image_names = np.loadtxt( obj.red_image_list, dtype=str )
    image_array = pyfits.getdata( image_names[ 0 ] )
    x_range = np.shape( image_array )[ 1 ]
    y_range = np.shape( image_array )[ 0 ]
    ax_tl.set_xlim( [ 0, x_range ] )
    ax_tl.set_ylim( [ 0, y_range ] )
    # Bottom left panel = airmass
    ax_bl = fig1.add_axes( [ edge_buffer, edge_buffer, 0.75*ax_width, ax_height ] )
    ax_bl.plot( time_from_start[ ix ], obj.airmasses[ ix ], '-k', lw=linewidth )
    ax_bl.plot( time_from_start[ ix ], obj.airmasses[ ix ], 'or', ms=markersize )
    ax_bl.set_xlabel( 'Time from start' )
    ax_bl.set_ylabel( 'Airmass' )
    ax_bl.set_xlim( [ xl, xu ] )
    ax_bl.xaxis.set_major_formatter( matplotlib.ticker.OldScalarFormatter() )
    ax_bl.yaxis.set_major_formatter( matplotlib.ticker.OldScalarFormatter() )
    # Top right panel = absolute photometry for each star
    ax_tr = plt.axes( [ 2*edge_buffer + 0.75*ax_width, 2*edge_buffer + ax_height, 1.25*ax_width, ax_height ] )
    for i in range( obj.nstars ):
        color = colormap.to_rgba( color_points[ i ] )
        ax_tr.errorbar( time_from_start[ ix ], obj.absphot_vals_all[ :, i ][ ix ], yerr=obj.absphot_errs_all[ :, i ][ ix ], \
                        fmt='-o', lw=linewidth, mfc=color, mec=color, c=color, ecolor=color, ms=markersize, label='star%i' % i )
    ax_tr.legend()
    ax_tr.set_title( 'Absolute Photometry' )
    ax_tr.set_xlabel( 'Time' )
    ax_tr.set_ylabel( 'Total Counts Within Aperture' )
    ax_tr.xaxis.set_major_formatter( matplotlib.ticker.OldScalarFormatter() )
    ax_tr.yaxis.set_major_formatter( matplotlib.ticker.OldScalarFormatter() )
    # Bottom right panel = sky values from each star
    ax_br = plt.axes( [ 2*edge_buffer + 0.75*ax_width, edge_buffer, 1.25*ax_width, ax_height ], sharex=ax_tr )
    for i in range( obj.nstars ):
        color = colormap.to_rgba( color_points[ i ] )
        ax_br.errorbar( time_from_start[ ix ], obj.skyvals[ :, i ][ ix ], yerr=obj.skystdvs[ :, i ][ ix ], fmt='-o', \
                        mfc=color, mec=color, c=color, ecolor=color, lw=linewidth, ms=markersize, label='star%i' % i )
    ax_br.legend()
    ax_br.set_title( 'Sky Background - as calculated for each annulus' )
    ax_br.set_xlabel( 'Time from start' )
    ax_br.set_ylabel( 'Counts per pixel' )
    ax_br.set_xlim( [ xl, xu ] )
    ax_br.xaxis.set_major_formatter( matplotlib.ticker.OldScalarFormatter() )
    ax_br.yaxis.set_major_formatter( matplotlib.ticker.OldScalarFormatter() )
    fig1.suptitle( obj.analysis_dir )
    plt.draw()
    # Now plot the measured scatter for each of the stars to compare against the formal Poissoin
    # noise value:
    fig2 = plt.figure( figsize=[ 12, 10 ] )
    ax = fig2.add_subplot( 111 )
    fig2.suptitle( obj.analysis_dir )
    ax.set_title( 'Noise Properties of Absolute Photometry (includes uncorrected correlated noise)' )
    ax.axhline( 1.0, ls='--', c='k', lw=linewidth )
    scatters = np.zeros( [ obj.nimages_total, obj.nstars ] )
    for i in range( obj.nstars ):
        if any( obj.absphot_errs_all[ :, i ]==0 ):
            scatters[ :, i ] = 0
        else:
            scatters[ :, i ] = np.std( obj.absphot_vals_all[ :, i ]) / obj.absphot_errs_all[ :, i ]
        color = colormap.to_rgba( color_points[ i ] )
        ax.plot( 1 + np.arange( obj.nimages_total ), scatters[ :, i ], '-o', lw=linewidth, ms=markersize, c=color, mfc=color, mec=color, label='star%i' % i )
    scatter_range = np.max( scatters ) - np.min( scatters )
    ymax = max( [ max ( [ np.max( scatters ), 1.0 ] ) + 0.1*scatter_range, 1.5 ] )
    ymin = 0.0
    ax.set_xlim( [ 0, obj.nimages_total - 1 ] )
    ax.set_ylim( [ ymin, ymax ] )
    ax.set_xlabel( 'Image Number' )
    ax.set_ylabel( 'Measured Scatter / Calculated Poisson Noise' )
    ax.legend()
    plt.draw()
    # Save the figures:
    fig1_name = str( obj.analysis_dir + '/absphot_output.png' ).replace( '//', '/' )
    obj.absphot_figure = fig1_name
    fig1.savefig( fig1_name )
    fig2_name = str( obj.analysis_dir + '/absphot_poissoncheck.png' ).replace( '//', '/' )
    fig2.savefig( fig2_name )

    plt.switch_backend( orig_backend )
    return None
            
    
